# Domain Ubiquitous Language - QuietMatch

> **The Shared Vocabulary for QuietMatch**
>
> This document defines the canonical terms used across the entire QuietMatch platform. Use these terms consistently in code, APIs, database schemas, UI labels, and all communication.

---

## Table of Contents

- [Core Concepts](#core-concepts)
- [Identity & Authentication Domain](#identity--authentication-domain)
- [Profile Domain](#profile-domain)
- [Matching Domain](#matching-domain)
- [Scheduling Domain](#scheduling-domain)
- [Notification Domain](#notification-domain)
- [Verification Domain](#verification-domain)
- [Payment Domain](#payment-domain)
- [Privacy & Consent Domain](#privacy--consent-domain)
- [Value Objects](#value-objects)
- [Domain Events](#domain-events)
- [State Machines](#state-machines)

---

## Core Concepts

### Member
**Definition**: A registered user of the QuietMatch platform who has completed the onboarding process and has an active profile.

**Usage**: Use "Member" instead of "User" in domain contexts (ProfileService, MatchingService, SchedulingService). Use "User" only in IdentityService (authentication context).

**Example**:
```csharp
public class Member
{
    public MemberId Id { get; private set; }
    public Email Email { get; private set; }
    public MemberStatus Status { get; private set; }
    public DateTime JoinedAt { get; private set; }
}

public enum MemberStatus
{
    Active,
    Paused,      // Temporarily not receiving matches
    Suspended,   // Violated terms of service
    Deleted      // Soft-deleted, pending hard delete
}
```

**NOT**: "User" (except in IdentityService), "Customer", "Client", "Person"

---

### Profile
**Definition**: The comprehensive representation of a Member's personality, values, preferences, lifestyle, and privacy settings. The Profile is the foundation for matching.

**Scope**: Owned by ProfileService.

**Key Attributes**:
- PersonalityProfile
- Values
- Lifestyle
- PreferenceSet
- DealBreakers
- ExposureLevel (privacy control)

**Example**:
```csharp
public class MemberProfile : AggregateRoot
{
    public MemberId MemberId { get; private set; }
    public string FullName { get; private set; } // Encrypted
    public PersonalityProfile Personality { get; private set; }
    public Values Values { get; private set; }
    public Lifestyle Lifestyle { get; private set; }
    public PreferenceSet Preferences { get; private set; }
    public DealBreakerSet DealBreakers { get; private set; }
    public ExposureLevel ExposureLevel { get; private set; }
    public bool IsComplete { get; private set; }
}
```

**NOT**: "UserProfile", "Account", "Bio"

---

### Match
**Definition**: A pairing of two Members determined by the matching algorithm to have high compatibility. A Match is a proposal that Members can accept or decline.

**Lifecycle**:
1. **Proposed**: System generates match based on compatibility
2. **Presented**: Match shown to one or both Members
3. **Accepted**: Both Members accept the match
4. **Declined**: At least one Member declines
5. **Expired**: Not acted upon within time limit

**Example**:
```csharp
public class Match : AggregateRoot
{
    public MatchId Id { get; private set; }
    public MemberId InitiatorId { get; private set; }
    public MemberId PartnerId { get; private set; }
    public CompatibilityScore Compatibility { get; private set; }
    public MatchStatus Status { get; private set; }
    public DateTime ProposedAt { get; private set; }
    public DateTime? AcceptedAt { get; private set; }

    public void Accept()
    {
        if (Status != MatchStatus.Presented)
            throw new DomainException("Can only accept presented matches");

        Status = MatchStatus.Accepted;
        AcceptedAt = DateTime.UtcNow;
        RaiseDomainEvent(new MatchAccepted(Id, InitiatorId, PartnerId, AcceptedAt.Value));
    }
}

public enum MatchStatus
{
    Proposed,   // Generated by algorithm, not yet shown
    Presented,  // Shown to Member(s), awaiting response
    Accepted,   // Both Members accepted
    Declined,   // One or both Members declined
    Expired     // Time limit passed without action
}
```

**NOT**: "Connection", "Pair", "Couple", "Link"

---

### BlindDate
**Definition**: A scheduled in-person meeting between two Members who have accepted a Match. "Blind" refers to the optional privacy feature where photos/names may not be revealed until the date or until consent is given.

**Scope**: Owned by SchedulingService.

**Key Attributes**:
- DateId
- MatchId (references the Match that led to this date)
- InitiatorId, PartnerId
- AvailabilitySlot (time and duration)
- VenueType (coffee shop, park, activity center)
- DateStatus (Proposed, Confirmed, Cancelled, Completed)

**Example**:
```csharp
public class BlindDate : AggregateRoot
{
    public BlindDateId Id { get; private set; }
    public MatchId MatchId { get; private set; }
    public MemberId InitiatorId { get; private set; }
    public MemberId PartnerId { get; private set; }
    public AvailabilitySlot TimeSlot { get; private set; }
    public VenueType VenueType { get; private set; }
    public DateStatus Status { get; private set; }

    public void Confirm()
    {
        if (Status != DateStatus.Proposed)
            throw new DomainException("Can only confirm proposed dates");

        Status = DateStatus.Confirmed;
        RaiseDomainEvent(new BlindDateConfirmed(Id, InitiatorId, PartnerId, TimeSlot));
    }

    public void Cancel(MemberId cancelledBy, string reason)
    {
        if (Status == DateStatus.Completed || Status == DateStatus.Cancelled)
            throw new DomainException("Cannot cancel completed or already cancelled dates");

        Status = DateStatus.Cancelled;
        RaiseDomainEvent(new BlindDateCancelled(Id, cancelledBy, reason));
    }
}

public enum DateStatus
{
    Proposed,   // System suggested, awaiting confirmation
    Confirmed,  // Both Members confirmed
    Cancelled,  // One or both Members cancelled
    Completed,  // Date happened (based on check-in or time passed)
    NoShow      // One or both Members didn't attend
}
```

**NOT**: "Appointment", "Meeting", "Encounter", "Rendezvous"

---

### CompatibilityScore
**Definition**: A quantitative measure (0.0 to 1.0 or 0% to 100%) of how well two Members' profiles align, broken down by weighted factors.

**Components**:
- **Overall Score**: Weighted average of all factors
- **Values Alignment**: How closely core values match (40% weight)
- **Lifestyle Compatibility**: How compatible daily habits and routines are (30% weight)
- **Communication Style**: How well communication preferences align (20% weight)
- **Interest Overlap**: Shared hobbies and interests (10% weight)

**Example**:
```csharp
public class CompatibilityScore : ValueObject
{
    public double Overall { get; private set; }
    public double ValuesAlignment { get; private set; }
    public double LifestyleCompatibility { get; private set; }
    public double CommunicationStyle { get; private set; }
    public double InterestOverlap { get; private set; }

    public CompatibilityScore(double values, double lifestyle, double communication, double interests)
    {
        ValuesAlignment = values;
        LifestyleCompatibility = lifestyle;
        CommunicationStyle = communication;
        InterestOverlap = interests;

        // Weighted calculation
        Overall = (values * 0.4) + (lifestyle * 0.3) + (communication * 0.2) + (interests * 0.1);
    }

    public CompatibilityLevel GetLevel()
    {
        return Overall switch
        {
            >= 0.9 => CompatibilityLevel.Excellent,
            >= 0.8 => CompatibilityLevel.High,
            >= 0.7 => CompatibilityLevel.Good,
            >= 0.6 => CompatibilityLevel.Moderate,
            _ => CompatibilityLevel.Low
        };
    }
}

public enum CompatibilityLevel
{
    Low,        // < 60%
    Moderate,   // 60-69%
    Good,       // 70-79%
    High,       // 80-89%
    Excellent   // 90%+
}
```

**NOT**: "MatchScore", "Rating", "Percentage"

---

## Identity & Authentication Domain

### User
**Definition**: In IdentityService context only, represents an authenticated account with login credentials (social login). Once a User completes profile creation, they become a Member.

**Scope**: IdentityService only. Do NOT use in other services (use Member instead).

**Example**:
```csharp
// IdentityService/Domain/Entities/User.cs
public class User
{
    public UserId Id { get; private set; }
    public Email Email { get; private set; }
    public AuthProvider Provider { get; private set; } // Google, Apple
    public string ExternalUserId { get; private set; } // Provider's user ID
    public DateTime CreatedAt { get; private set; }
}

public enum AuthProvider
{
    Google,
    Apple,
    // Future: Microsoft, Facebook (if needed)
}
```

---

### AccessToken
**Definition**: A short-lived JWT token (15 minutes) used to authenticate API requests. Contains claims (user ID, email, roles).

**Example**:
```csharp
public class AccessToken : ValueObject
{
    public string Token { get; private set; }
    public DateTime ExpiresAt { get; private set; }
    public UserId UserId { get; private set; }

    public bool IsExpired() => DateTime.UtcNow >= ExpiresAt;
}
```

---

### RefreshToken
**Definition**: A long-lived opaque token (7 days) used to obtain new AccessTokens without re-authentication. Stored in database, one per user session.

**Example**:
```csharp
public class RefreshToken : AggregateRoot
{
    public RefreshTokenId Id { get; private set; }
    public UserId UserId { get; private set; }
    public string Token { get; private set; } // Hashed before storage
    public DateTime ExpiresAt { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public bool IsRevoked { get; private set; }

    public void Revoke()
    {
        IsRevoked = true;
        RaiseDomainEvent(new RefreshTokenRevoked(Id, UserId));
    }
}
```

---

## Profile Domain

### PersonalityProfile
**Definition**: A structured representation of a Member's personality traits based on questionnaire responses. May include free-text responses for embedding generation.

**Example**:
```csharp
public class PersonalityProfile : ValueObject
{
    public int Openness { get; private set; }          // 1-5 scale (Big Five)
    public int Conscientiousness { get; private set; }
    public int Extraversion { get; private set; }
    public int Agreeableness { get; private set; }
    public int Neuroticism { get; private set; }

    public string AboutMe { get; private set; }         // Free text (for embeddings)
    public string LifePhilosophy { get; private set; }  // Free text (for embeddings)
}
```

---

### Values
**Definition**: Core values and priorities that guide a Member's life decisions. Critical for compatibility matching.

**Example**:
```csharp
public class Values : ValueObject
{
    public int FamilyOrientation { get; private set; }  // 1-5 scale (1=not important, 5=very important)
    public int CareerAmbition { get; private set; }
    public int Spirituality { get; private set; }
    public int Adventure { get; private set; }
    public int IntellectualCuriosity { get; private set; }
    public int SocialJustice { get; private set; }
    public int FinancialSecurity { get; private set; }
    public int Environmentalism { get; private set; }
}
```

---

### Lifestyle
**Definition**: Daily habits, routines, and lifestyle preferences.

**Example**:
```csharp
public class Lifestyle : ValueObject
{
    public SocialFrequency SocialFrequency { get; private set; }
    public ExerciseFrequency ExerciseFrequency { get; private set; }
    public DietaryPreference DietaryPreference { get; private set; }
    public PetOwnership PetOwnership { get; private set; }
    public SmokingStatus SmokingStatus { get; private set; }
    public DrinkingFrequency DrinkingFrequency { get; private set; }
}

public enum SocialFrequency
{
    Introvert,      // Rarely socialize, prefer alone time
    Occasional,     // Social 1-2 times/week
    Moderate,       // Social 3-4 times/week
    Extrovert       // Social almost daily
}

public enum PetOwnership
{
    NoPets,
    HasPets,
    WantsPetsInFuture,
    Allergic
}
```

---

### PreferenceSet
**Definition**: Member's preferences for their ideal match (age range, location, etc.). Distinct from DealBreakers.

**Example**:
```csharp
public class PreferenceSet : ValueObject
{
    public AgeRange PreferredAgeRange { get; private set; }
    public int MaxDistanceKm { get; private set; }
    public List<string> PreferredLanguages { get; private set; }
    public GenderPreference GenderPreference { get; private set; }
}

public class AgeRange : ValueObject
{
    public int MinAge { get; private set; }
    public int MaxAge { get; private set; }
}

public enum GenderPreference
{
    Men,
    Women,
    NonBinary,
    NoPreference
}
```

---

### DealBreaker
**Definition**: A non-negotiable requirement or incompatibility. If a potential match violates a DealBreaker, they are filtered out automatically.

**Example**:
```csharp
public class DealBreakerSet : ValueObject
{
    public bool MustWantChildren { get; private set; }
    public bool MustNotSmoke { get; private set; }
    public bool MustShareReligion { get; private set; }
    public bool MustBeVegetarian { get; private set; }
    public int MinimumEducationLevel { get; private set; }
}
```

---

### ExposureLevel
**Definition**: Privacy setting controlling how much of a Member's profile data is shared with others.

**Levels**:
- **MatchedOnly**: Only matched Members (after acceptance) can see full profile
- **AllMatches**: All presented matches can see profile (before acceptance)
- **Public**: Profile visible in future search features (opt-in)

**Example**:
```csharp
public enum ExposureLevel
{
    MatchedOnly,  // Highest privacy
    AllMatches,   // Moderate privacy
    Public        // Lowest privacy (future feature)
}
```

---

## Matching Domain

### MatchCandidate
**Definition**: A potential Match that has been identified by the matching algorithm but not yet formally created as a Match entity. Used internally during matching process.

**Example**:
```csharp
public class MatchCandidate : ValueObject
{
    public MemberId CandidateId { get; private set; }
    public CompatibilityScore CompatibilityScore { get; private set; }
    public DateTime EvaluatedAt { get; private set; }
    public string ReasonForMatch { get; private set; } // e.g., "High values alignment, shared interest in hiking"
}
```

---

### MatchSuggestion
**Definition**: A curated Match presented to a Member for acceptance or decline. Contains compatibility breakdown and conversation starters.

**Example**:
```csharp
public class MatchSuggestion : ValueObject
{
    public MatchId MatchId { get; private set; }
    public MemberId SuggestedPartnerId { get; private set; }
    public CompatibilityScore Compatibility { get; private set; }
    public List<string> SharedInterests { get; private set; }
    public List<string> ComplementaryDifferences { get; private set; }
    public List<string> ConversationStarters { get; private set; }
}
```

---

### MatchingEngine (Port)
**Definition**: Interface defining the contract for matching algorithms. Allows swapping between rule-based, ML-based, or embedding-based engines.

**Example**:
```csharp
public interface IMatchingEngine
{
    Task<IEnumerable<MatchCandidate>> FindCandidatesAsync(MemberId memberId, int limit);
    CompatibilityScore CalculateCompatibility(MemberProfile profile1, MemberProfile profile2);
}
```

---

## Scheduling Domain

### AvailabilitySlot
**Definition**: A time window when a Member is available for a BlindDate. Members pre-configure their general availability, and the system finds overlaps.

**Example**:
```csharp
public class AvailabilitySlot : ValueObject
{
    public MemberId MemberId { get; private set; }
    public DateTime StartTime { get; private set; }
    public DateTime EndTime { get; private set; }
    public DayOfWeek DayOfWeek { get; private set; }
    public bool IsRecurring { get; private set; } // e.g., "Every Tuesday 6-8 PM"

    public TimeSpan Duration => EndTime - StartTime;

    public bool OverlapsWith(AvailabilitySlot other)
    {
        return StartTime < other.EndTime && EndTime > other.StartTime;
    }
}
```

---

### VenueType
**Definition**: Category of location suggested for a BlindDate. Not a specific venue, but a type (coffee shop, park, activity center).

**Example**:
```csharp
public enum VenueType
{
    CoffeeShop,     // Casual, 1-hour duration
    Restaurant,     // Moderate, 1.5-2 hour duration
    Park,           // Outdoor, 1-2 hour duration
    ActivityCenter, // e.g., bowling, mini-golf (2-3 hour duration)
    Museum,         // Cultural, 2-3 hour duration
    Bar             // Evening, 1.5-2 hour duration
}
```

---

### DateProposal
**Definition**: System-generated suggestion for a BlindDate time and venue, sent to both Members for confirmation.

**Example**:
```csharp
public class DateProposal : ValueObject
{
    public DateTime ProposedTime { get; private set; }
    public VenueType VenueType { get; private set; }
    public TimeSpan EstimatedDuration { get; private set; }
    public string ProposalReason { get; private set; } // e.g., "Both available, near city center"
}
```

---

## Notification Domain

### Notification
**Definition**: A message sent to a Member via one or more channels (email, push, in-app).

**Types**:
- **MatchNotification**: New match suggested
- **BlindDateNotification**: Date scheduled, reminder, cancellation
- **MessageNotification**: Future: In-app messaging
- **SystemNotification**: Account updates, privacy changes

**Example**:
```csharp
public class Notification : AggregateRoot
{
    public NotificationId Id { get; private set; }
    public MemberId RecipientId { get; private set; }
    public NotificationType Type { get; private set; }
    public NotificationChannel Channel { get; private set; }
    public string Subject { get; private set; }
    public string Body { get; private set; }
    public NotificationStatus Status { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? SentAt { get; private set; }
}

public enum NotificationType
{
    MatchSuggestion,
    MatchAccepted,
    BlindDateScheduled,
    BlindDateReminder,
    BlindDateCancelled,
    ProfileIncomplete,
    SystemAnnouncement
}

public enum NotificationChannel
{
    Email,
    Push,
    InApp,
    SMS  // Future
}

public enum NotificationStatus
{
    Pending,
    Sent,
    Failed,
    Retrying
}
```

---

## Verification Domain

### VerificationRequest
**Definition**: A request to verify a Member's phone number or identity document.

**Types**:
- **PhoneVerification**: SMS code verification (Twilio Verify)
- **IDVerification**: Document verification (Veriff, IDWise)

**Example**:
```csharp
public class VerificationRequest : AggregateRoot
{
    public VerificationRequestId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public VerificationType Type { get; private set; }
    public VerificationStatus Status { get; private set; }
    public DateTime RequestedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    public string VerificationCode { get; private set; } // For phone verification
}

public enum VerificationType
{
    Phone,
    IdentityDocument
}

public enum VerificationStatus
{
    Pending,
    CodeSent,
    Verified,
    Failed,
    Expired
}
```

---

### VerificationBadge
**Definition**: A visual indicator on a Member's profile showing they've been verified. Increases trust and match priority.

**Example**:
```csharp
public class VerificationBadge : ValueObject
{
    public VerificationType Type { get; private set; }
    public DateTime VerifiedAt { get; private set; }
    public DateTime ExpiresAt { get; private set; } // ID verification may expire after 1 year
}
```

---

## Payment Domain

### Subscription
**Definition**: A Member's payment plan (Free, Premium, Premium Plus) with billing cycle and status.

**Example**:
```csharp
public class Subscription : AggregateRoot
{
    public SubscriptionId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public PlanType Plan { get; private set; }
    public SubscriptionStatus Status { get; private set; }
    public DateTime StartedAt { get; private set; }
    public DateTime? EndsAt { get; private set; }
    public BillingCycle BillingCycle { get; private set; }
    public decimal Price { get; private set; }
    public string StripeSubscriptionId { get; private set; }

    public void Activate()
    {
        Status = SubscriptionStatus.Active;
        RaiseDomainEvent(new SubscriptionActivated(Id, MemberId, Plan));
    }

    public void Cancel()
    {
        Status = SubscriptionStatus.Cancelled;
        EndsAt = DateTime.UtcNow.AddDays(30); // Grace period
        RaiseDomainEvent(new SubscriptionCancelled(Id, MemberId));
    }
}

public enum PlanType
{
    Free,
    Premium,      // €9.99/month
    PremiumPlus   // €19.99/month
}

public enum SubscriptionStatus
{
    Active,
    PastDue,     // Payment failed, retrying
    Cancelled,   // User cancelled, in grace period
    Expired      // Grace period ended
}

public enum BillingCycle
{
    Monthly,
    Yearly  // 30% discount
}
```

---

## Privacy & Consent Domain

### ConsentToken
**Definition**: A record of a Member's consent for specific data processing activities. Required by GDPR.

**Example**:
```csharp
public class ConsentToken : AggregateRoot
{
    public ConsentTokenId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public ConsentType Type { get; private set; }
    public ConsentStatus Status { get; private set; }
    public DateTime GrantedAt { get; private set; }
    public DateTime? RevokedAt { get; private set; }
    public int ConsentVersion { get; private set; } // Track privacy policy versions

    public void Revoke()
    {
        Status = ConsentStatus.Revoked;
        RevokedAt = DateTime.UtcNow;
        RaiseDomainEvent(new ConsentRevoked(Id, MemberId, Type));
    }
}

public enum ConsentType
{
    DataProcessing,        // General data processing
    MatchingAlgorithm,     // Use profile for matching
    Notifications,         // Send notifications
    Analytics,             // Anonymized analytics
    ThirdPartySharing,     // Share with partners (e.g., venues)
    MarketingCommunications
}

public enum ConsentStatus
{
    Granted,
    Revoked,
    Expired  // Consent must be re-confirmed periodically
}
```

---

### DataExportRequest
**Definition**: A Member's request to download all their data (GDPR Article 15: Right to Access).

**Example**:
```csharp
public class DataExportRequest : AggregateRoot
{
    public DataExportRequestId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public RequestStatus Status { get; private set; }
    public DateTime RequestedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    public string DownloadUrl { get; private set; } // Temporary signed URL
}

public enum RequestStatus
{
    Pending,
    Processing,
    Completed,
    Failed
}
```

---

### DataDeletionRequest
**Definition**: A Member's request to delete all their data (GDPR Article 17: Right to Erasure). Triggers a SAGA across all services.

**Example**:
```csharp
public class DataDeletionRequest : AggregateRoot
{
    public DataDeletionRequestId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public RequestStatus Status { get; private set; }
    public DateTime RequestedAt { get; private set; }
    public DateTime SoftDeletedAt { get; private set; } // Immediate soft delete
    public DateTime ScheduledHardDeleteAt { get; private set; } // 30 days later
    public DateTime? CompletedAt { get; private set; }
}
```

---

## Value Objects

### MemberId, UserId, MatchId, BlindDateId, etc.
**Definition**: Strongly-typed identifiers to prevent mixing up IDs from different aggregates.

**Example**:
```csharp
public record MemberId(Guid Value)
{
    public static MemberId New() => new(Guid.NewGuid());
    public static MemberId Parse(string value) => new(Guid.Parse(value));
}

public record MatchId(Guid Value)
{
    public static MatchId New() => new(Guid.NewGuid());
}

// Usage:
public class Match
{
    public MatchId Id { get; private set; }
    public MemberId InitiatorId { get; private set; }
    public MemberId PartnerId { get; private set; }

    // Type safety: Cannot accidentally pass a MatchId where MemberId is expected
}
```

---

### Email
**Definition**: Value object representing a validated email address.

**Example**:
```csharp
public record Email
{
    public string Value { get; private init; }

    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value) || !value.Contains('@'))
            throw new DomainException("Invalid email address");

        Value = value.ToLowerInvariant();
    }
}
```

---

## Domain Events

### Naming Convention
**Pattern**: `{Aggregate}{ActionPastTense}`

**Examples**:
- `MatchAccepted` (not `AcceptMatch` or `MatchAcceptedEvent`)
- `ProfileUpdated` (not `UpdateProfile`)
- `BlindDateScheduled` (not `ScheduleBlindDate`)

### Event Catalog

**Identity Domain**:
- `UserRegistered`
- `RefreshTokenRevoked`

**Profile Domain**:
- `ProfileCreated`
- `ProfileUpdated`
- `ProfileCompleted` (questionnaire finished)
- `PreferencesUpdated`

**Matching Domain**:
- `MatchProposed`
- `MatchPresented`
- `MatchAccepted`
- `MatchDeclined`
- `MatchExpired`

**Scheduling Domain**:
- `AvailabilitySlotCreated`
- `BlindDateProposed`
- `BlindDateConfirmed`
- `BlindDateCancelled`
- `BlindDateCompleted`
- `BlindDateNoShow`

**Notification Domain**:
- `NotificationSent`
- `NotificationFailed`

**Verification Domain**:
- `VerificationRequested`
- `VerificationCodeSent`
- `VerificationCompleted`
- `VerificationFailed`

**Payment Domain**:
- `SubscriptionStarted`
- `SubscriptionActivated`
- `SubscriptionCancelled`
- `SubscriptionExpired`
- `PaymentReceived`
- `PaymentFailed`

**Privacy Domain**:
- `ConsentGranted`
- `ConsentRevoked`
- `DataExportRequested`
- `DataExportCompleted`
- `DataDeletionRequested`
- `DataDeletionCompleted`

---

## State Machines

### Match Status Flow
```
Proposed → Presented → Accepted → [BlindDate created]
                  ↘ Declined
                  ↘ Expired
```

### BlindDate Status Flow
```
Proposed → Confirmed → Completed
              ↓
          Cancelled
              ↓
          NoShow
```

### Subscription Status Flow
```
Active → PastDue → Active (payment recovered)
   ↓         ↓
Cancelled → Expired
```

---

## Anti-Patterns to Avoid

### DON'T Use Generic Terms

❌ **Bad**: `User` (everywhere), `Appointment`, `Meeting`, `Record`, `Data`, `Info`

✅ **Good**: `Member` (domain contexts), `BlindDate`, `ConsentToken`, `MatchSuggestion`

### DON'T Mix Contexts

❌ **Bad**: Using `User` in ProfileService
```csharp
// ProfileService (WRONG)
public class User
{
    public string FullName { get; set; }
    public PersonalityProfile Personality { get; set; }
}
```

✅ **Good**: Using `Member` in ProfileService, `User` only in IdentityService
```csharp
// IdentityService (CORRECT)
public class User
{
    public UserId Id { get; private set; }
    public Email Email { get; private set; }
}

// ProfileService (CORRECT)
public class MemberProfile
{
    public MemberId MemberId { get; private set; }
    public string FullName { get; private set; }
}
```

### DON'T Use Primitive Obsession

❌ **Bad**: Using `Guid` everywhere
```csharp
public class Match
{
    public Guid Id { get; set; }
    public Guid Member1 { get; set; }
    public Guid Member2 { get; set; }
}
```

✅ **Good**: Strongly-typed IDs
```csharp
public class Match
{
    public MatchId Id { get; private set; }
    public MemberId InitiatorId { get; private set; }
    public MemberId PartnerId { get; private set; }
}
```

---

## Usage Checklist

When writing code, ensure:

- [ ] All domain terms match this document exactly
- [ ] No synonyms used (e.g., don't use "Appointment" if "BlindDate" is defined)
- [ ] Event names follow past-tense convention
- [ ] Strongly-typed IDs used instead of `Guid` or `int`
- [ ] Value objects used for complex types (Email, CompatibilityScore)
- [ ] Domain events raised for state changes
- [ ] Comments reference ubiquitous language terms

---

**This ubiquitous language is the foundation of QuietMatch. Treat it as law.**

**Next Steps**:
- See [SAGA Processes](04_saga-processes.md) for distributed workflow terminology
- Review [Glossary](../50_references/glossary.md) for quick term lookup
- Check microservice documentation for domain-specific usage

---

**Last Updated**: 2025-11-20
**Document Owner**: Domain Experts + Engineering Team
**Status**: Living Document (evolve as domain understanding deepens)
